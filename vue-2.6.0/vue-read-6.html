<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>捡到一颗白矮星</title>
    <meta name="generator" content="VuePress 1.4.1">
    
    <meta name="description" content="总是听到自己心跳的声音">
    <link rel="preload" href="/mylife/assets/css/0.styles.fc64af32.css" as="style"><link rel="preload" href="/mylife/assets/js/app.e5007391.js" as="script"><link rel="preload" href="/mylife/assets/js/2.1a757213.js" as="script"><link rel="preload" href="/mylife/assets/js/25.df3f3611.js" as="script"><link rel="prefetch" href="/mylife/assets/js/10.ddba6f7d.js"><link rel="prefetch" href="/mylife/assets/js/11.131d49be.js"><link rel="prefetch" href="/mylife/assets/js/12.d7120a9f.js"><link rel="prefetch" href="/mylife/assets/js/13.a78dea17.js"><link rel="prefetch" href="/mylife/assets/js/14.c8afcf48.js"><link rel="prefetch" href="/mylife/assets/js/15.d497dbf9.js"><link rel="prefetch" href="/mylife/assets/js/16.bc6f7740.js"><link rel="prefetch" href="/mylife/assets/js/17.40433173.js"><link rel="prefetch" href="/mylife/assets/js/18.ac5f649e.js"><link rel="prefetch" href="/mylife/assets/js/19.7ddc6507.js"><link rel="prefetch" href="/mylife/assets/js/20.1b19e468.js"><link rel="prefetch" href="/mylife/assets/js/21.c283fa7e.js"><link rel="prefetch" href="/mylife/assets/js/22.b70fefc9.js"><link rel="prefetch" href="/mylife/assets/js/23.c17da845.js"><link rel="prefetch" href="/mylife/assets/js/24.77dcfd42.js"><link rel="prefetch" href="/mylife/assets/js/26.554398ff.js"><link rel="prefetch" href="/mylife/assets/js/27.5b6289aa.js"><link rel="prefetch" href="/mylife/assets/js/28.d0c806db.js"><link rel="prefetch" href="/mylife/assets/js/3.b8c48841.js"><link rel="prefetch" href="/mylife/assets/js/4.fca74266.js"><link rel="prefetch" href="/mylife/assets/js/5.0c495115.js"><link rel="prefetch" href="/mylife/assets/js/6.dd4e8536.js"><link rel="prefetch" href="/mylife/assets/js/7.30939716.js"><link rel="prefetch" href="/mylife/assets/js/8.5477dec8.js"><link rel="prefetch" href="/mylife/assets/js/9.77d79079.js">
    <link rel="stylesheet" href="/mylife/assets/css/0.styles.fc64af32.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/mylife/" class="home-link router-link-active"><!----> <span class="site-name">捡到一颗白矮星</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/mylife/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/chunmu" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/mylife/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="https://github.com/chunmu" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/mylife/" class="sidebar-link">Home</a></li><li><a href="/mylife/todo/" class="sidebar-link">要和宝宝要做的一百件事</a></li><li><a href="/mylife/noagain/" class="sidebar-link">让宝宝不开心的事情</a></li><li><a href="/mylife/source/" class="sidebar-link">资源收集</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue-2.6.0</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>javascript</span> <span class="arrow right"></span></p> <!----></section></li><li><a href="/mylife/less/" class="sidebar-link">less</a></li><li><a href="/mylife/color/" class="sidebar-link">color</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><blockquote><p>这篇文章我们将讲mount相关的内容，app初始dom挂载通过 new Vue().mount()完成</p></blockquote> <h3 id="_1-c-createelement"><a href="#_1-c-createelement" class="header-anchor">#</a> 1. _c = createElement</h3> <blockquote><p>对gencode生成结果执行，生成对应的vnode树</p></blockquote> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/**
* 1. createElement 参数整理
* 2. _createElement 
* 3. 检查data.__bo__，不能用含有监听标记的对象作为vnode的data，在render的时候提供一个全新对象使用，data是解析得到的数据 类似{staticClass: 'xxx'}
* 4. 处理用户自行调用createElement时候的逻辑
*   if (isDef(data) &amp;&amp; isDef(data.is)) {
*      tag = data.is
*    }
*    在之前碰到的模板中直接&lt;div :is=&quot;xx&quot;&gt;这种形式会被如下处理，所以这边是
*    if ((binding = getBindingAttr(el, 'is'))) {
*      el.component = binding
*    }
*    果然 用jsx生成 获取用户如果用户提供的is值 
*        child: {
*          render () {
*            return this.$createElement('div', {is: false})
*          }
*        }
* 5. 如果用户提供的tag不合法 例如is给的值为假值，找不到tag，则返回一个empty VNode
* 6. 接下来是判断key的构成 理论上只支持数字或者字符串 如果有@binding动态绑定也行，但是求得的值也应该是原始值 字符串或者数字
* 7. 允许提供的children第一顺位为一个方法 且设置为scopedSlots的默认处理方法,也就是插槽的默认内容
* 8. 提供一个开关normalizeChildren，是否需要每次经过额外的children校验和处理逻辑，理论上提供的是正常的child node节点合集，但是可以切换开关，
*    处理各种骚操作 比如用户提供的children = ['xxx', _c(), ...]  'xxx'需要额外包装一层，得到一个text类型的vnode
*    举个例子  h = createElement(tag, data, children)  children可能出现的额情况如下
*    ['子节点1', _c(), _c()]  || ['子节点1', [_c(), _c()]]  || ['子节点1', '子节点2', [_c(), _c()]]
*    这类情况嵌套数组应该是为了照顾用户分类设置子节点，children中元素对应的都是h的子节点，二维数组是方便用户的一种表现形式
*    自己点元素类型可以是数字，字符串等 会包装秤vnode，但是要注意，子节点唯一对应的vnode是唯一的，如果使用两个外在形式相同的元素，也需要调用createElement来生成不同的vnode   
* 9. 开始对tag进行判断分类处理  如果tag是字符串
*    (1). 如果是普通浏览器保留标签或者是用户自留标签，直接生成对应vnode，
*    (2). 如果没有带有data并且可以在options链中找到对应components配置的对象，调用createComponent直接创建相关的组件节点VNode
*         createComponent相关信息可以查看  ### 2. createComponent
*    (3). 最后一种情境是未知的或者未定义的标签处理
* 10. 如果tag是一个对象，直接调用createComponent
* 11. 对createComponent处理返回的vnode进行判断处理 如果是数组 直接返回
*     如果是没有返回值 返回空vnode
* */</span>


</code></pre></div><h3 id="_2-createcomponent"><a href="#_2-createcomponent" class="header-anchor">#</a> 2. createComponent</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code>
<span class="token comment">/**
* 1. const baseCtor = context.$options._base 获取构造器
* 2. 刚刚分析了Ctor有两种来源 第一个是components中获取组件配置对象，另一种是用户自定义的配置对象
* 3. 将配置对象Ctor经过 Vue也就是_base的extend方法进行包装处理 回顾一下extend的处理逻辑,合并祖先options，并且返回一个Vue类的扩展构造器Sub，所以每一个组件都要经过这么一个流程，实例多了就傻b了
*    最近有碰到的场景就是element-ui中树形组件数量巨大的性能问题，很大原因就是实例数量过多
*    是组件实例 并不是标签,需要维护一个完整的生命周期
* 4. 异步组件的处理,没有做特殊处理,创建一个空节点vnode，并且打上标记 asyncMeta = { data, context, children, tag } node.asyncFactory = factory
* 5. 关于异步组件  回顾一下使用方式
*    Vue.component('async-component', function () {}) 注意 传入的是一个function
*    在注册全局component的时候，可以发现type === 'component' &amp;&amp; isPlainObject(definition),如果不是一个对象 并不会执行extend，所以还没有Vue挂载的相关api，当然也没有cid
*    isUndef(Ctor.cid)  如果没有 当成是一个异步组件，需要创建一个vnode用来占位
*    调用的是resolveAsyncComponent来处理 详情查看 #### 2.1 resolveAsyncComponent
*    
* */</span>

</code></pre></div><h4 id="_2-1-resolveasynccomponent"><a href="#_2-1-resolveasynccomponent" class="header-anchor">#</a> 2.1. resolveAsyncComponent</h4> <div class="language-javascript extra-class"><pre class="language-javascript"><code>
<span class="token comment">/**
* 1. 在定义异步组件的时候提供一个工厂方法factory
* 2. 我们讲的createComponent都是运行时方法，如果factory.error则判断组件信息获取失败，查看是否有errorComp失败占位组件
* 3. 查看是否resolved组件 就是工厂方法已经执行完且有结果resolved
* 4. 接下来就是异步组件还没有获取到的占位处理逻辑
*    (1). 找出当前render的父实例 该异步组件的拥有者之一
*    (2). factory的owners收集owner
*    (3). 如果有loading标记且有loading组件，渲染该过渡组件
*    (4). 如果是初始化，并没有渲染过，则配置owners，且记录sync=true标记
*    (5). ;(owner: any).$on('hook:destroyed', () =&gt; remove(owners, owner)),如果owner，则移除该异步组件的所属关系
* 5. 执行factory，对返回值res进行判断处理，如果是一个promise对象，分别执行resolve,reject执行链
*    如果res.component是一个promise，加上then处理，有个大家比较熟悉的就是vue router中 component: () =&gt; xxx这种方式，对应的就是它了
*    分别判断是否需要调动配置的错误占位组件或者loading组件
*    如果配置的delay === 0，loading生效，如果在delay后还没有resolve，调起loading组件使用，且通知所属父组件强制更新当前渲染状态，
*    在timeout的时间内，并没有resolved，调起reject
*    对应的resolve处理方法，赋值resolved，扩展成了Vue类
*    如果是异步，
*/</span>


<span class="token comment">/**
* 6. 如果是异步 调用强制更新 会出现渲染loading组件 或者渲染目标组件
*    如果是同步，则执行完resolveAsyncComponent直接返回目标组件对象，取消所属关系
* */</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sync<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">forceRender</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  owners<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
* 7. 超时时间的处理 用户自定义超时限制
* */</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>timeout<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>factory<span class="token punctuation">.</span>resolved<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">reject</span><span class="token punctuation">(</span>
        process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span>
          <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">timeout (</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>res<span class="token punctuation">.</span>timeout<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">ms)</span><span class="token template-punctuation string">`</span></span>
          <span class="token operator">:</span> <span class="token keyword">null</span>
      <span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> res<span class="token punctuation">.</span>timeout<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
* 8. 如果返回的位undefined 也就是异步组件 resolved还未定义，创建一个vnode占位
* */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>Ctor <span class="token operator">===</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// return a placeholder node for async component, which is rendered</span>
  <span class="token comment">// as a comment node but preserves all the raw information for the node.</span>
  <span class="token comment">// the information will be used for async server-rendering and hydration.</span>
  <span class="token keyword">return</span> <span class="token function">createAsyncPlaceholder</span><span class="token punctuation">(</span>
    asyncFactory<span class="token punctuation">,</span>
    data<span class="token punctuation">,</span>
    context<span class="token punctuation">,</span>
    children<span class="token punctuation">,</span>
    tag
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_2-1-resolveasynccomponent-2"><a href="#_2-1-resolveasynccomponent-2" class="header-anchor">#</a> 2.1. resolveAsyncComponent</h4> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">/**
* 9. 更新全局配置信息 可能会有调用Vue.mixin这种事件发生 注册了新的filter 组件等
* */</span>
<span class="token function">resolveConstructorOptions</span><span class="token punctuation">(</span>Ctor<span class="token punctuation">)</span>


<span class="token comment">/**
* 10. 后续再来看这段
* */</span>

<span class="token function">transformModel</span><span class="token punctuation">(</span>Ctor<span class="token punctuation">.</span>options<span class="token punctuation">,</span> data<span class="token punctuation">)</span>

<span class="token comment">/**
* 11. propsdata解析 后续回头看这段
* */</span>

<span class="token keyword">const</span> propsData <span class="token operator">=</span> <span class="token function">extractPropsFromVNodeData</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> Ctor<span class="token punctuation">,</span> tag<span class="token punctuation">)</span>

<span class="token comment">/**
* 12. 函数式组件 回头看
* */</span>

<span class="token function">createFunctionalComponent</span><span class="token punctuation">(</span>Ctor<span class="token punctuation">,</span> propsData<span class="token punctuation">,</span> data<span class="token punctuation">,</span> context<span class="token punctuation">,</span> children<span class="token punctuation">)</span>



<span class="token comment">/**
* 13. 抽象组件 只保留slot
* */</span>

<span class="token keyword">const</span> slot <span class="token operator">=</span> data<span class="token punctuation">.</span>slot
data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>slot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  data<span class="token punctuation">.</span>slot <span class="token operator">=</span> slot
<span class="token punctuation">}</span>

<span class="token comment">/**
* 14. 安装组件钩子  不是实例生命周期钩子
* */</span>

componentVNodeHooks <span class="token operator">=</span> <span class="token punctuation">{</span>init<span class="token punctuation">,</span> prepatch<span class="token punctuation">,</span> insert<span class="token punctuation">,</span> destory<span class="token punctuation">}</span>

<span class="token comment">/**
* 15. 创建组件占位vnode，vnode标签 `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`
* */</span>

</code></pre></div><h3 id="_3-render流程"><a href="#_3-render流程" class="header-anchor">#</a> 3 render流程</h3> <blockquote><p>在new Vue().$mount()时候发生的事情</p></blockquote> <h4 id="_3-1-mount"><a href="#_3-1-mount" class="header-anchor">#</a> 3.1 $mount</h4> <div class="language-javascript extra-class"><pre class="language-javascript"><code>
<span class="token comment">/**
* 1. new Vue().$mount调用的是覆盖定义的Vue.prototype.$mount = function外层处理方法
* */</span>

<span class="token comment">// 核心mount挂载方法</span>
<span class="token keyword">const</span> mount <span class="token operator">=</span> <span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>$mount

<span class="token comment">// 挂载路口过渡方法</span>
<span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">$mount</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">/**
* 2. 校验 应用挂载目标不能是body或者html标签
* */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>el <span class="token operator">===</span> document<span class="token punctuation">.</span>body <span class="token operator">||</span> el <span class="token operator">===</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span> <span class="token operator">&amp;&amp;</span> <span class="token function">warn</span><span class="token punctuation">(</span>
    <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.</span><span class="token template-punctuation string">`</span></span>
  <span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
* 3. 如果没有render内容，则需要获取template并且调用编译模块进行解析
* 4. 处理完之后 调用核心mount处理逻辑 mountComponent
* */</span>

</code></pre></div><h4 id="_3-2-mountcomponent"><a href="#_3-2-mountcomponent" class="header-anchor">#</a> 3.2 mountComponent</h4> <div class="language-javascript extra-class"><pre class="language-javascript"><code>
<span class="token comment">/**
* 1. 如果没有render 构造一个空vnode占位 保证逻辑执行没问题,在非生产环境下将会得到非法格式报错，没有提供模板或者ast解析对象
* */</span>

vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>render <span class="token operator">=</span> createEmptyVNode

<span class="token comment">/**
* 2. 调起组件实例生命周期钩子 beforeMount,在这个钩子执行的时候，主流程会继续往下走,并且不是马上就完成挂载 还有很多处理流程
* */</span>

<span class="token comment">/**
* 3. 调起_update更新
* */</span>

<span class="token function-variable function">updateComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token function">_render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span>
<span class="token punctuation">}</span>


<span class="token keyword">const</span> prevEl <span class="token operator">=</span> vm<span class="token punctuation">.</span>$el  <span class="token comment">// 获取旧的el</span>
<span class="token keyword">const</span> prevVnode <span class="token operator">=</span> vm<span class="token punctuation">.</span>_vnode  <span class="token comment">// 获取旧的vnode</span>
<span class="token keyword">const</span> restoreActiveInstance <span class="token operator">=</span> <span class="token function">setActiveInstance</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>  <span class="token comment">// 设置当前激活实例 后面会用于挂载子组件实例</span>

vm<span class="token punctuation">.</span>_vnode <span class="token operator">=</span> vnode <span class="token comment">// 保存当前节点作为旧节点 再次_update时将会作为旧节点</span>

<span class="token comment">/**
 * 4. __patch__调用该方法完成dom派发渲染  关于该方法请查看 ### 4. __patch__
*/</span>

<span class="token comment">// 如果不存在旧节点 新建</span>
vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">__patch__</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$el<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> hydrating<span class="token punctuation">,</span> <span class="token boolean">false</span> <span class="token comment">/* removeOnly */</span><span class="token punctuation">)</span>

<span class="token comment">// 更新</span>
vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">__patch__</span><span class="token punctuation">(</span>prevVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>

<span class="token comment">/**
 * 5. 整理vm和el的关系
*/</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>prevEl<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  prevEl<span class="token punctuation">.</span>__vue__ <span class="token operator">=</span> <span class="token keyword">null</span>  <span class="token comment">// 解除绑定 旧的vm将被回收</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span>$el<span class="token punctuation">.</span>__vue__ <span class="token operator">=</span> vm    <span class="token comment">// 新的el与vm的绑定关系</span>
<span class="token punctuation">}</span>


</code></pre></div><h3 id="_4-patch"><a href="#_4-patch" class="header-anchor">#</a> 4. <strong>patch</strong></h3> <blockquote><p><strong>patch</strong> = createPatchFunction() 是一个函数执行后的返回值 且返回值也是一个函数</p></blockquote> <h3 id="_4-1-createpatchfunction中执行后返回的方法patch"><a href="#_4-1-createpatchfunction中执行后返回的方法patch" class="header-anchor">#</a> 4.1 createPatchFunction中执行后返回的方法patch</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code>
<span class="token comment">/**
 * 1. 装载各指令的钩子处理函数 eg:内置指令 v-model ['create', 'activate', 'update', 'remove', 'destroy'] 
*/</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> hooks<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  cbs<span class="token punctuation">[</span>hooks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> modules<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>modules<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>hooks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      cbs<span class="token punctuation">[</span>hooks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>modules<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>hooks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 2. 如果现vnode未定义且oldVnode也未定义 直接中断patch,如果有vnode没有oldvnode，作为一个小会旧节点的逻辑操作
*/</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isUndef</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">invokeDestroyHook</span><span class="token punctuation">(</span>oldVnode<span class="token punctuation">)</span>
  <span class="token keyword">return</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 3. 在又新节点vnode的前提下如果没有旧节点oldVnode 表示新建组件createElm
*/</span>

<span class="token comment">// 已经使用的组件不能直接继续使用 克隆一份vnode数据</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>elm<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDef</span><span class="token punctuation">(</span>ownerArray<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token comment">// patch方法内函数createComponent()</span>
<span class="token comment">// 如果之前已经挂载有实例vm componentInstance，并且是keepAlive缓存组件</span>
<span class="token comment">// 调起挂载的组件钩子  init</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>i <span class="token operator">=</span> i<span class="token punctuation">.</span>hook<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDef</span><span class="token punctuation">(</span>i <span class="token operator">=</span> i<span class="token punctuation">.</span>init<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">i</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> <span class="token boolean">false</span> <span class="token comment">/* hydrating */</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 4. init钩子的调用
*/</span>


<span class="token keyword">if</span> <span class="token punctuation">(</span>
  vnode<span class="token punctuation">.</span>componentInstance <span class="token operator">&amp;&amp;</span>
  <span class="token operator">!</span>vnode<span class="token punctuation">.</span>componentInstance<span class="token punctuation">.</span>_isDestroyed <span class="token operator">&amp;&amp;</span>
  vnode<span class="token punctuation">.</span>data<span class="token punctuation">.</span>keepAlive
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 如果已经有挂载实例 且未销毁状态 且缓存 当做是一次更新渲染</span>
  <span class="token keyword">const</span> mountedNode<span class="token operator">:</span> any <span class="token operator">=</span> vnode
  <span class="token comment">// 直接调起组件钩子prepatch</span>
  componentVNodeHooks<span class="token punctuation">.</span><span class="token function">prepatch</span><span class="token punctuation">(</span>mountedNode<span class="token punctuation">,</span> mountedNode<span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> child <span class="token operator">=</span> vnode<span class="token punctuation">.</span>componentInstance <span class="token operator">=</span> <span class="token function">createComponentInstanceForVnode</span><span class="token punctuation">(</span>
    vnode<span class="token punctuation">,</span>
    activeInstance
  <span class="token punctuation">)</span>
  child<span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span>hydrating <span class="token operator">?</span> vnode<span class="token punctuation">.</span>elm <span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">/**
 * 5. createComponentInstanceForVnode 为vnode创建实例
*/</span>
<span class="token comment">// options中的_parentVnode指向关联vnode 并不是父级的意思 而是从vnode衍生出来的实例</span>
<span class="token keyword">const</span> options<span class="token operator">:</span> InternalComponentOptions <span class="token operator">=</span> <span class="token punctuation">{</span>
  _isComponent<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  _parentVnode<span class="token operator">:</span> vnode<span class="token punctuation">,</span>
  parent <span class="token comment">// parent是当前处理状态的vnode实例 这里就是完整渲染树衔接的关键部分</span>
  <span class="token comment">/**
   * 假设我们是在渲染一个应用根节点 我们再调用mount的时候已经存在了一个实例vm 且在执行mount的试试 当前激活实例activeInstance赋值
   * 在渲染过程中找到一个节点的标签符合自定义组件名称限定 判断是一个用户自定义组件
   * 牛逼
   * 在子组件新建时查找当前激活实例activeInstance,绑定父子关系 就链接了两个渲染树的关系
  */</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 6. 我们看看prepatch做了啥
*/</span>
<span class="token comment">// 获取options 组件配置 获取旧有实例 调起updateChildComponent #### 4.4 updateChildComponent</span>
<span class="token keyword">const</span> options <span class="token operator">=</span> vnode<span class="token punctuation">.</span>componentOptions
<span class="token keyword">const</span> child <span class="token operator">=</span> vnode<span class="token punctuation">.</span>componentInstance <span class="token operator">=</span> oldVnode<span class="token punctuation">.</span>componentInstance
<span class="token function">updateChildComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      #### <span class="token number">4.4</span> updateChildComponent


<span class="token comment">/**
 * 7. 如果有oldVnode 走更新流程
*/</span>
<span class="token function">patchVnode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 如果是vnode复用  需要复制一份vnode</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>elm<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDef</span><span class="token punctuation">(</span>ownerArray<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// clone reused vnode</span>
  vnode <span class="token operator">=</span> ownerArray<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">cloneVNode</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 8. hydrate处理
*/</span>
<span class="token comment">// 如果旧节点是异步处理节点 且如果该异步节点的resolved有值 调用hydrate处理</span>
<span class="token comment">// 如果还未resolve，标记当前节点vnode.isAsyncPlaceholder = true 继续占位 不进行处理</span>
<span class="token comment">// 可以看看这个函数执行的地方 </span>
<span class="token comment">// 第一个是patchVnode   一般是比较两个新旧节点之间的更新行为</span>
<span class="token comment">// patch方法中如果是服务端渲染处理流程</span>
<span class="token function">hydrate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 看看这个函数做了什么</span>

<span class="token comment">// 如果不是有效的节点类型 返回false</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">assertNodeMatch</span><span class="token punctuation">(</span>elm<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> inVPre<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 是否为vue-component等</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 执行钩子</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>i <span class="token operator">=</span> data<span class="token punctuation">.</span>hook<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDef</span><span class="token punctuation">(</span>i <span class="token operator">=</span> i<span class="token punctuation">.</span>init<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">i</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* hydrating */</span><span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>i <span class="token operator">=</span> vnode<span class="token punctuation">.</span>componentInstance<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// child component. it should have hydrated its own tree.</span>

    <span class="token function">initComponent</span><span class="token punctuation">(</span>vnode<span class="token punctuation">,</span> insertedVnodeQueue<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="_4-2-invokedestroyhook-组件销毁和失活流程"><a href="#_4-2-invokedestroyhook-组件销毁和失活流程" class="header-anchor">#</a> 4.2 invokeDestroyHook 组件销毁和失活流程</h4> <blockquote><p>销毁组件需要关注两个事情 一个是实例上绑定的各种数据和监听器 一个是组件失活处理</p></blockquote> <div class="language-javascript extra-class"><pre class="language-javascript"><code>
<span class="token comment">/**
 * 1. 如果vnode.data挂载了数据 一般是创建组件的时候会挂载组件钩子函数 ['insert', 'init', 'destory']等
*/</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span>i <span class="token operator">=</span> data<span class="token punctuation">.</span>hook<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isDef</span><span class="token punctuation">(</span>i <span class="token operator">=</span> i<span class="token punctuation">.</span>destroy<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">i</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span> <span class="token comment">// 先调用vnode钩子destory</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cbs<span class="token punctuation">.</span>destroy<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> cbs<span class="token punctuation">.</span>destroy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span> <span class="token comment">// 再调用指令钩子destory</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 2. 组件钩子destory的内容
*/</span>

<span class="token function">destroy</span> <span class="token punctuation">(</span><span class="token parameter">vnode<span class="token operator">:</span> MountedComponentVNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> componentInstance <span class="token punctuation">}</span> <span class="token operator">=</span> vnode
  <span class="token comment">/**
   * 这边这个判断条件需要注意一下 个人想法如下
   * 在patch中不传第二个参数可以调起销毁流程 直接vm.$destory也可以调起销毁流程
   * 如果两个流程操作的部分有重叠  需要这个标识来做处理_isDestroyed,对性能是有帮助的
   * 同理inactive激活失活类似
   * */</span> 
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>componentInstance<span class="token punctuation">.</span>_isDestroyed<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果示例未销毁状态 需要走销毁流程</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>vnode<span class="token punctuation">.</span>data<span class="token punctuation">.</span>keepAlive<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果没有keepAlive缓存，则销毁实例</span>
      componentInstance<span class="token punctuation">.</span><span class="token function">$destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// 如果是缓存实例 失活处理</span>
      <span class="token function">deactivateChildComponent</span><span class="token punctuation">(</span>componentInstance<span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token comment">/* direct */</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 3. 我们看看实例销毁做了什么事情 $destroy
*/</span>

<span class="token comment">// 判断是否正在销毁中</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_isBeingDestroyed<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span>
<span class="token punctuation">}</span>

<span class="token comment">// 调用beforeDestroy</span>
<span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeDestroy'</span><span class="token punctuation">)</span>

<span class="token comment">// 移除父子关联</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>parent<span class="token punctuation">.</span>_isBeingDestroyed <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>abstract<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">remove</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span>$children<span class="token punctuation">,</span> vm<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 卸载监听器</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_watcher<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span>_watcher<span class="token punctuation">.</span><span class="token function">teardown</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> i <span class="token operator">=</span> vm<span class="token punctuation">.</span>_watchers<span class="token punctuation">.</span>length
<span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span>_watchers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">teardown</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 这边这个判断条件需要注意一下 个人想法如下
 * 在patch中不传第二个参数可以调起销毁流程 直接vm.$destory也可以调起销毁流程
 * 如果两个流程操作的部分有重叠  需要这个标识来做处理_isDestroyed,对性能是有帮助的
 * 同理inactive激活失活类似
 * */</span> 
<span class="token comment">// 实例上的$destory方法再次发起销毁流程__patch__</span>
<span class="token comment">// 重点 按照销毁逻辑来看 子级组件销毁在前 依次由内到外调用destory钩子</span>
vm<span class="token punctuation">.</span><span class="token function">__patch__</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_vnode<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span>

<span class="token comment">// 卸载所有事件监听相关 不带参数的卸载  清空em._events对象</span>
vm<span class="token punctuation">.</span><span class="token function">$off</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 

<span class="token comment">/**
 * 3. 这里说一下事件销毁逻辑
*/</span>
<span class="token comment">// 3.1 清空事件 一般是销毁组件的时候调用  vm._events清空</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>arguments<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span>_events <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> vm
<span class="token punctuation">}</span>
<span class="token comment">// 3.2 移除指定事件</span>
<span class="token comment">// 只提供事件名称的处理 删除逻辑</span>
<span class="token keyword">const</span> cbs <span class="token operator">=</span> vm<span class="token punctuation">.</span>_events<span class="token punctuation">[</span>event<span class="token punctuation">]</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cbs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> vm
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span>_events<span class="token punctuation">[</span>event<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span>
  <span class="token keyword">return</span> vm
<span class="token punctuation">}</span>
<span class="token comment">// 处理事件绑定是一个数组handler的情况 找出符合条件的方法移除</span>
<span class="token keyword">let</span> cb
<span class="token keyword">let</span> i <span class="token operator">=</span> cbs<span class="token punctuation">.</span>length
<span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  cb <span class="token operator">=</span> cbs<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>cb <span class="token operator">===</span> fn <span class="token operator">||</span> cb<span class="token punctuation">.</span>fn <span class="token operator">===</span> fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cbs<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">break</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><h4 id="_4-3-createcomponent"><a href="#_4-3-createcomponent" class="header-anchor">#</a> 4.3 createComponent</h4> <div class="language-javascript extra-class"><pre class="language-javascript"><code>
</code></pre></div><h3 id="_3-patch-方法，分发视图更新"><a href="#_3-patch-方法，分发视图更新" class="header-anchor">#</a> 3. __patch__方法，分发视图更新</h3> <blockquote><p>patch = createPatchFunction执行后返回的函数</p></blockquote> <div class="language-javascript extra-class"><pre class="language-javascript"><code>
<span class="token comment">/**
* 1. 策略集合strats，初始值optionMergeStrategies，也就是提供给用户自行定义合并策略的一个入口
* 2. strats.data
*  (1). 关于这里 data为什么必须是一个function  因为通过data方法执行获取到的对象是一个新的对象副本
*  (2). 如果data为一个对象 则可能出现多个vue实例共享这个data对象 则可能出现不可控的问题 不同实例修改数据会反映在这一个data对象
*  (3). 每个options本质上就是一个vue对象的配置信息，可单配置，多个实例
*  (4). 基本校验
* 3. in a Vue.extend merge, both should be functions这个注释的意思是，他们是实例的构造函数，提供的data必须是一个函数,如果是实例那以他们为构造函数new出来的对象就会共享一个data实例
* 4. 没有vm的情况下，也就是extend扩展的构造函数内合并options，mergeDataOrFn返回一个合并策略方法，
*    那么结果extend下的data策略就是返回一个函数，该函数调用data下的数据合并处理过程mergeData
*    strat['data'] = 
* 5. mergeData递归处理data下面字段的方法，先判断支不支持新语法，通过Reflect.ownKeys获取当前对象上的自有属性
*    const keys = hasSymbol   
*      ? Reflect.ownKeys(from)
*      : Object.keys(from)
* 6. 这边有个    if (key === '__ob__') continue判断条件，这是预防该层级对象已经处于被观测状态，被观测的对象会带有__ob__标记,如果没有且属于字面值变量，则设置
* 7. 如果目标对象中没有对应的to[key],则需要调用观测方法，不论是对象或者字面值，如果存在则判断是否为对象，如果是对象则递归处理，不过从源码来看，字面值是以to对象为准，要合并到的目标为准,
*    比如： comA的data() {
*      return {
*        username: 'comA',
*      }
*    }
*    mixins: [{
*      data () {
*        username: 'comMixin'
*      }
*    }]
*    最后username = comA，以它的为准，具体场景表现为如果从mixin中有data()优先级低于生成实例时配置的options
* 8. 生命周期钩子的合并策略
*    并不是覆盖，而是累加，可能两个同名钩子处理逻辑须共存
*    如果钩子存在，需要构造一个保存狗仔集合的新数组，备份，避免共享实例的问题
* 9. assets钩子,component，directive, filter等得合并策略，直接使用覆盖操作，目标对象优先级高
* 10. strats.watch的合并策略
*    (1). if (!childVal) return Object.create(parentVal || null),如果不存在目标对象，直接以parentVal为蓝本生成一份return
*    (2). 格式校验，watch必须是一个对象
*    (3). 把需要合并的对象和目标对象的watch每个属性都改造成数组，因为这种watch合并不是简单的覆盖，而可能是处理逻辑的叠加，可能需要并存，所以存在下面这种格式
*      watch = {
*        username: [{
*          handler1: () =&gt; {}
*        }, {
*          handler2: () =&gt; {}
*        }]
*      }
* 11. props, methods, inject, computed的合并策略相同，直接使用覆盖操作，目标对象优先级高
* 12. strats.provide策略同data策略类似
* 13. 如果不存在合并策略，则使用默认合并策略，也就是如果childVal存在，则用它，否则用parentVal
* 14. 合并策略部分结束
* */</span>

</code></pre></div><h3 id="_1-4-updatelisteners"><a href="#_1-4-updatelisteners" class="header-anchor">#</a> 1.4 updateListeners</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code>
<span class="token comment">/**
* 1. 规范化事件名称，之前模板解析的修饰符这边处理，判断是否含有capture，passive，once等得修饰符标记
* 2. isUndef(cur)，当前需要绑定的事件对应的handler未定义，也就是 @click=&quot;xxx&quot;  xxx未定义
* 3. 如果需要替换的事件不存在，也就是新增事件，创建一个Invoker
* export function createFnInvoker (fns: Function | Array&lt;Function&gt;, vm: ?Component): Function {
*    function invoker () {
*      const fns = invoker.fns
*      if (Array.isArray(fns)) {
*        // 如果是数组 遍历调用handler
*        const cloned = fns.slice()
*        for (let i = 0; i &lt; cloned.length; i++) {
*          invokeWithErrorHandling(cloned[i], null, arguments, vm, `v-on handler`)
*        }
*      } else {
*        // return handler return value for single handlers
*        return invokeWithErrorHandling(fns, null, arguments, vm, `v-on handler`)
*      }
*    }
*    invoker.fns = fns   // 挂载的handler集合
*    return invoker      // invoker()执行之时就会处理方法内的内容
*  }
* 4. 判断是否为一次性事件,生成一个执行函数，执行后$off卸载监听
* function createOnceHandler (event, fn) {
*    const _target = target
*    return function onceHandler () {
*      const res = fn.apply(null, arguments)
*      if (res !== null) {
*        _target.$off(event, onceHandler)
*      }
*    }
*  }
* 5. 调用$on新增事件监听
* 6. 如果当前handler与旧的handler不等，修改invoker上需要执行的函数集合fns,invoker相关信息绑定到新的新的listener中on[name] = old
* 7. 如果事件名称在目标对象中不存在，在旧有事件集合中存在，则需要进行卸载操作，调用$off
* */</span>

</code></pre></div><h3 id="_1-5-数据初始化内容-initprops"><a href="#_1-5-数据初始化内容-initprops" class="header-anchor">#</a> 1.5 数据初始化内容 initProps</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code>
<span class="token comment">/**
* 1. initProps, 初始化props数据，说明props的数据优先级在methods，data之上
* 2. 缓存key数组，后续访问props数据直接遍历key数组，不用动态访问props对象的键，后续有用到这边这个伏笔
* 3. 校验props数据的合法性,也就是关于数据的type校验，default的获取等
*     props: {
*       showSubmit: {
*         type: Boolean,
*         default: true
*       }
*     }
* 4. isReservedAttribute进行关键字检查,比如slot，key，ref等，不能以这些作为props传入子组件
* 5. 设置props元素的set方法，拦截用户在子组件中对props的修改并告警
* 6. defineReactive设置props的观测系统，如果父组件中有修改props中的值，会执行相关update
* 7. 只有是根节点或者isUpdatingChildComponent中才能修改props中的值 这边需要补充具体场景
* 8. proxy(vm, `_props`, key),设置代理,访问props中的元素其实访问的都是vm._props中的数据
* */</span>

</code></pre></div><h3 id="_1-6-数据初始化内容-initmethods初始化方法"><a href="#_1-6-数据初始化内容-initmethods初始化方法" class="header-anchor">#</a> 1.6 数据初始化内容 initMethods初始化方法</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code>
<span class="token comment">/**
* 1. initMethods, 初始化methods数据，优先级在data之上
* 2. 判断类型，只能是func
* 3. 查看是否对应的key是否已经在vm中绑定
* 4. 查看是否为保留方法名 比如生命周期钩子，不能冲突使用
* 5. bind(methods[key], vm)，这就是为什么methods中能访问到vm实例的原因了  this.xxx = function () {console.log(this)} this是vm实例
* */</span>

</code></pre></div><h3 id="_1-7-数据初始化内容-initdata，-initwatcher-initcomputed初始化方法"><a href="#_1-7-数据初始化内容-initdata，-initwatcher-initcomputed初始化方法" class="header-anchor">#</a> 1.7 数据初始化内容 initData， initWatcher, initComputed初始化方法</h3> <blockquote><p>这边就涉及到了响应式管理了，内容留着，放在下一篇讲</p></blockquote> <div class="language-javascript extra-class"><pre class="language-javascript"><code>
<span class="token comment">/**
* 1. 优先级: data &gt; computed &gt; watch 
* */</span>

</code></pre></div><h3 id="_1-8-总结"><a href="#_1-8-总结" class="header-anchor">#</a> 1.8 总结</h3> <p>主要是一些数据处理，还有就是两个生命周期钩子的调用 beforecreate，created，他们可以定义为async方法，不过并不会阻塞后续的主流程执行，建议大家照着源码来看我的学习记录，谢谢大家，流程图明天补上，今天先到者了，大家冬至快乐</p> <br> <br>
如果可以，请喝杯咖啡，ヾ(≧▽≦*)o
<p><img src="https://user-gold-cdn.xitu.io/2019/12/13/16efafe4704796ea?w=287&amp;h=288&amp;f=jpeg&amp;s=41747" alt=""></p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/mylife/assets/js/app.e5007391.js" defer></script><script src="/mylife/assets/js/2.1a757213.js" defer></script><script src="/mylife/assets/js/25.df3f3611.js" defer></script>
  </body>
</html>
